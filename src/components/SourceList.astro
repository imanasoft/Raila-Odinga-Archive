---
import { formatDate } from '@utils/format';
import type { SourceMeta } from '@utils/sources';

interface MetadataTextEntry {
  label: string;
  type?: 'text';
  value: string;
}

interface MetadataLinkEntry {
  label: string;
  type: 'link';
  href: string;
  text: string;
}

interface MetadataTimeEntry {
  label: string;
  type: 'time';
  dateTime: string;
  text: string;
}

type MetadataEntry = MetadataTextEntry | MetadataLinkEntry | MetadataTimeEntry;

interface Props {
  sources: SourceMeta[];
}

const languageLabels: Record<string, string> = {
  en: 'English'
};

const toTitleCase = (value: string) =>
  value
    .split(/[-_]/)
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join(' ');

const formatList = (items?: string[]) =>
  items && items.length > 0 ? items.map((item) => toTitleCase(item)).join(', ') : undefined;

const safeFormatDate = (value?: string) => {
  if (!value) return undefined;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return undefined;
  return formatDate(date);
};

const formatLanguage = (code?: string) => {
  if (!code) return undefined;
  return languageLabels[code] ?? code;
};

const props = Astro.props as Props;

const sortedSources = [...props.sources].sort((a, b) => a.title.localeCompare(b.title));

const sourcesWithMetadata = sortedSources.map((source) => {
  const metadata: MetadataEntry[] = [];

  const formats = formatList(source.type);
  if (formats) {
    metadata.push({ label: 'Formats', value: formats });
  }

  const topics = formatList(source.topics);
  if (topics) {
    metadata.push({ label: 'Topics', value: topics });
  }

  const criticalAreas = formatList(source.criticalAreas);
  if (criticalAreas) {
    metadata.push({ label: 'Critical Coverage', value: criticalAreas });
  }

  const formattedPublication = safeFormatDate(source.publicationDate);
  if (formattedPublication && source.publicationDate) {
    metadata.push({
      label: 'Published',
      type: 'time',
      dateTime: source.publicationDate,
      text: formattedPublication
    });
  }

  const formattedRetrieval = safeFormatDate(source.retrievalDate);
  if (formattedRetrieval && source.retrievalDate) {
    metadata.push({
      label: 'Retrieved',
      type: 'time',
      dateTime: source.retrievalDate,
      text: formattedRetrieval
    });
  }

  const language = formatLanguage(source.language);
  if (language) {
    metadata.push({ label: 'Language', value: language });
  }

  if (source.license) {
    metadata.push({ label: 'License', value: source.license });
  }

  if (source.archiveUrl) {
    metadata.push({ label: 'Archive', type: 'link', href: source.archiveUrl, text: 'Archived copy' });
  }

  return {
    ...source,
    metadata
  };
});
---
<ul class="source-list">
  {sourcesWithMetadata.map((source) => (
    <li class="source-list__item">
      <article class="source-card">
        <header class="source-card__header">
          <h3 class="source-card__title">
            {source.url ? <a href={source.url}>{source.title}</a> : source.title}
          </h3>
          <p class="source-card__id">
            <span>ID:</span> <code>{source.id}</code>
          </p>
          {source.publisher && <p class="source-card__publisher">{source.publisher}</p>}
        </header>

        {source.metadata.length > 0 && (
          <dl class="source-card__meta">
            {source.metadata.map((entry) => (
              <>
                <dt>{entry.label}</dt>
                <dd>
                  {entry.type === 'link' ? (
                    <a href={entry.href}>{entry.text}</a>
                  ) : entry.type === 'time' ? (
                    <time dateTime={entry.dateTime}>{entry.text}</time>
                  ) : (
                    entry.value
                  )}
                </dd>
              </>
            ))}
          </dl>
        )}

        {(source.reliability || source.reliabilityNotes) && (
          <div class="source-card__reliability">
            {source.reliability?.assessment && (
              <p>
                <strong>Reliability:</strong> {source.reliability.assessment}
                {source.reliability?.rationale && <> â€” {source.reliability.rationale}</>}
              </p>
            )}
            {source.reliabilityNotes && (
              <p>
                <strong>Notes:</strong> {source.reliabilityNotes}
              </p>
            )}
          </div>
        )}
      </article>
    </li>
  ))}
</ul>
